/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  static = true;
  //DEBUG_PARSER = true;
}

PARSER_BEGIN(FreshMeat)
 
package parser;
import view.Tela;
import controleDeArquivos.CreateFile;
import recovery.*;
import java.io.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JOptionPane;
import javax.swing.JFileChooser;

public class FreshMeat
{
  	final static Tela window = new Tela();
  	static private String console = "";
  
  	//private static String myFile = "";
    int contParseError = 0; // contador de erros sintáticos
	
  	public static void main(String args []) throws ParseException
  	{
	    window.setVisible(true);
	
		window.getCompilar().addActionListener(new ActionListener()
		{
    		public void actionPerformed(ActionEvent e)
    		{
				window.setVazioConsoleMsg();

	            if((window.getTextArquivo().getText().equals(window.getCampoTexto())) != true)
				{
	  				window.setControleArquivo(false);
				}
				
				if(window.getControleArquivo() || window.getTextArquivo().getText().equals(" ") )
				{
		            try
		            {
						RunAskella();
					}
					catch (ParseException e1)
					{
						e1.printStackTrace();
					}
	            }
	            else
	            {
	           		if(window.getTextArquivo().getText().equals(""))
	        		{
	            		JOptionPane.showMessageDialog (null, "Arquivo vazio", "Arquivo", JOptionPane.WARNING_MESSAGE);
	        		}
	        		else
	        		{
	          			int resp = JOptionPane.showConfirmDialog(null, "Salvar altera\u00e7\u00f5es?");
	
		          		if(resp == 0)
		          		{
				            //Salvar um novo arquivo se ele n existir
				            if(window.getFile() == null)
			            	{
			                	window.salvarComo();
		                        try
		                        {
									RunAskella();
								}
								catch (ParseException e1)
								{
									e1.printStackTrace();
								}
			
			            		}
		            		else //Se o arquivo ja existir salvar nele
		            		{
			                	window.salvar();
	                            try
	                            {
									RunAskella();
								}
								catch (ParseException e1)
								{
									e1.printStackTrace();
								}
								
	            			}
	          			}
	        		}
	            }
	    	}
		});
  	}

  	public static void RunAskella() throws ParseException
    {
    	FileReader arql = null;
      
        try
        {
			arql = new FileReader(window.getFile());
		}
		catch (FileNotFoundException e2)
		{
			e2.printStackTrace();
		}
			BufferedReader arq = new BufferedReader(arql);
	    try
	    {
	      	FreshMeat parser = new FreshMeat(arq);
	      	JOptionPane.showMessageDialog(window, "Compilado com sucesso!");
	    }
	    catch (Exception e1)
	    {
	      	FreshMeat.ReInit(arq);
	    }
	    catch (Error e1)
   		{
   		  	FreshMeat.ReInit(arq);
   		}

        try
        {
            SimpleNode simpleNode = FreshMeat.start();
            simpleNode.dump("", window);
            //;

      	}
        catch (ParseException e)
        {
            lnlog("Exception: A express\u00e3o inserida n\u00e3o est\u00e1 correta, verifique por favor com as instru\u00e7\u00f5es abaixo e tente novamente.");
            lnlog(e.getMessage());
            //lnlog(e);
            //parser.contParseError = 1;   // não existe recuperação de erros
            //System.exit(0);			  	
        }
        catch (Error e)
        {
            lnlog("Error: A entrada inserida n\u00e3o \u00e9 um token v\u00e1lido ou o arquivo está vazio, revise por favor e tente novamente");
       		//System.out.println("error");
            lnlog(e.getMessage());
        }
//     	finally
//    	{
//      	lnlog(token_source.foundLexError() + " Lexical Errors found");
//        	lnlog(contParseError + " Syntactic Errors found");
//     	}  
        }
		
	static private void log(String s)
	{
		console = s;
		window.setConsole(console);
  	}

  	static private void lnlog(String s)
  	{
  		log(s + "\n");
  	}
	
    static public String im(int x)
    {
		int k;
		String s;
		s = tokenImage[x];
		k = s.lastIndexOf("\u005c"");
		try
		{
	      s = s.substring(1,k);
		}
        catch (StringIndexOutOfBoundsException e)
        {
        }
        return s;
  	}

  	static Token lastError = null;
  	static boolean eof;    // variável que indica se EOF foi alcançado

  	// o método abaixo consome tokens até alcançar um que pertença ao conjunto
  	// de sincronização
  	static void consumeUntil(RecoverySet g,
	                         ParseException e,
	                         String met) throws ParseEOFException,
	                                            ParseException
 	{
		Token tok;
        //lnlog();

        lnlog("*** " + met + " ***");
        lnlog("     Conjunto de sincroniza\u00e7\u00e3o: " + g);

        if (g == null) throw e; // se o conjunto é null, propaga a exceção

        tok = getToken(1); // pega token corrente

        while ( ! eof )
        { // se não chegou ao fim do arquivo
	      	if ( g.contains(tok.kind))
	      	{	//achou um token no conjunto
	            lnlog("     Encontrado token de sincroniza\u00e7\u00e3o: " +
	                               im(tok.kind));
	        break;
	      	}
	      	lnlog("     Ignorando o token: " + im(tok.kind));
	      	getNextToken();     // pega próximo token       
	      	tok = getToken(1);
	      	if (tok.kind == EOF && ! g.contains(EOF) ) // fim da entrada?   
	              eof = true;
        }
    	if ( tok != lastError)
    	{
          	lnlog(e.getMessage());
          	lastError = tok;
        }
        	if ( eof )
          		throw new ParseEOFException("Encontrei EOF onde n\u00e3o deveria.");
  }
  
}

PARSER_END(FreshMeat)

TOKEN_MGR_DECLS :
{
	int countLexError = 0;
	
	public int foundLexError()
	{
	   return countLexError;
	}
}

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

TOKEN : /* Reserved words */
{
  	< STARTSCRIPT : "Start" >
| 	< INTEGERTYPE : "int" >
| 	< STRINGTYPE : "string" >
| 	< BOOLTYPE : "bool" >
| 	< USING : "using" >
| 	< IF : "if">
| 	< THEN : "then">
| 	< ELSE : "else">
| 	< FOR : "for">
| 	< TO : "to">
| 	< WHILE : "while" >

}

TOKEN : /* Operadores */
{
	< SUM: "+" >
|	< MINUS: "-" >
|	< PLUS: "*" >
|	< DIVIDE: "/" >	
|	< ASSIGN: "="> 
|	< GREATER: ">" >
|	< LESS: "<" >
|	< GREATEREQUAL: ">=" >
|	< LESSEQUAL: "<=" >
|	< DIFFERENCE: "!=" >
|	< EQUAL: "==" >	

}

TOKEN: /* Simbolos especiais */
{
	< LBRACE : "{" >
| 	< RBRACE : "}" >
| 	< VARCHARDELIMITER : "'" >
| 	< SEMICOLON : ";" >
| 	< COMMA : "," >
| 	< DOUBLEPOINTS : ":" >
| 	< LPARENT : "(" >
| 	< RPARENT : ")" >
| 	< HASHTAG : "#" >

}

TOKEN :
{
 	< ID  : < LETTER > (< LETTER > | < DIGIT >)* >
| 	< LETTER : ["A"-"Z" ] | ["a"-"z"] >
|   < NUMBER: (<DIGIT>)+ ( "." (<DIGIT>)+ )? >
| 	< #DIGIT : [ "0"-"9" ] >

}

SKIP:
{
	"/*": multilinecomment
}

< multilinecomment > SKIP:
{
  	"*/": DEFAULT
| 	< ~ [] >
}

SKIP:
{
	"//": singlelinecomment
}

< singlelinecomment > SKIP:
{ 
  	< ["\n", "\r"] >: DEFAULT
| 	< ~ [] >
}

SimpleNode start() :{ RecoverySet recoverySet = First.start; }
{
	try
  	{
		(UsingDeclaration())*
		  
		StartScript() DoublePoints() Id()
		LBrace()
		
			(Block())+
		
		RBrace()
  		<EOF>
		
		{ return jjtThis; }
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "start");  
  		}
  		catch(ParseEOFException eof)
  		{
    
  		}  
	}

}
   
void Block(): { RecoverySet recoverySet = First.Block; }
{
  	try
  	{
  		(VariableDeclaration())*
  	
  		Command() 
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "Block");  
  		}
  		catch(ParseEOFException eof)
  		{
    
  		}  
	}
}

void Command(): { RecoverySet recoverySet = First.Command; }
{
	try
  	{
			VariableAssignment()
				
		| 	If()
		 
		| 	ForTo()
		
		| 	While()
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "Command");  
  		}
  		catch(ParseEOFException eof)
  		{
     
  		}  
	}
}

void VariableAssignment(): { RecoverySet recoverySet = First.VariableAssignment; }
{
	try
  	{
		Id() VariableInit() SemiColon()
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "VariableInit");  
  		}
  		catch(ParseEOFException eof)
  		{
    
  		}  
	}
}

void VariableInit(): { RecoverySet recoverySet = First.VariableInit; }
{
	try
  	{
  		Assign() Y()
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "VariableInit");  
  		}
  		catch(ParseEOFException eof)
  		{
    
  		}  
	}
}

void Y(): { RecoverySet recoverySet = First.Y; }
{
	try
  	{
  		( (Number() | Id()) (DoMath())* ) | W()
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "Y");  
  		}
  		catch(ParseEOFException eof)
  		{
    
  		}  
	} 
}

void W(): { RecoverySet recoverySet = First.W; }
{
	try
  	{
  	 	(StringDelimit() Id() StringDelimit())
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "W");  
  		}
  		catch(ParseEOFException eof)
  		{
    
  		}  
	} 
}

void DoMath(): { RecoverySet recoverySet = First.DoMath; }
{
 	try
  	{
	 	(MathOperator() ExpressionArguments())
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "DoMath");  
  		}
  		catch(ParseEOFException eof)
  		{
    
  		}  
	}
}

void If(): { RecoverySet recoverySet = First.If; }
{
	try
  	{
		IF() LogicExpression() Then()
				(LBrace()	Command()	RBrace() )
				(Else()		LBrace()		Command()	RBrace() )?
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "If");  
  		}
  		catch(ParseEOFException eof)
  		{
    
  		}  
	}			
}

void ForTo(): { RecoverySet recoverySet = First.ForTo; }
{
	try
  	{
		FOR() VariableAssignment() To() ExpressionArguments()
	 	(LBrace()
	 		Command()
	 	RBrace() )
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "ForTo");  
  		}
  		catch(ParseEOFException eof)
  		{
    
  		}  
	}
}

void While(): { RecoverySet recoverySet = First.While; }
{ 
	try
  	{
		WHILE() LogicExpression()
	 	(LBrace()
	 		Command()
	 	RBrace() )
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "While");  
  		}
  		catch(ParseEOFException eof)
  		{
    
  		}  
	}	
} 

void LogicExpression(): { RecoverySet recoverySet = First.LogicExpression; }
{
	try
  	{
  		ExpressionArguments() (LogicOperator() ExpressionArguments())+
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "LogicExpression");  
  		}
  		catch(ParseEOFException eof)
  		{
    
  		}  
	}
}

void ExpressionArguments(): { RecoverySet recoverySet = First.ExpressionArguments; }
{
	try
  	{
  		Id() | Number()
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "ExpressionArguments");  
  		}
  		catch(ParseEOFException eof)
  		{
    
  		}  
	}
}

void MathOperator(): { RecoverySet recoverySet = First.MathOperator; }
{
	try
  	{
		 	Sum()
		|	Minus()
		|	Plus()
		|	Divide()
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "MathOperator");  
  		}
  		catch(ParseEOFException eof)
  		{
    
  		}  
	}
}

void LogicOperator(): { RecoverySet recoverySet = First.LogicOperator; }
{
	try
  	{
	  		Greater()
		|	Less()
		|	GreaterEqual()
		|	LessEqual()
		|	Difference()
		|	Equal()
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "LogicOperator");  
  		}
  		catch(ParseEOFException eof)
  		{
    
  		}  
	}
}

void UsingDeclaration(): { RecoverySet recoverySet = First.UsingDeclaration; }
{
	try
  	{
  		(Using() Id() SemiColon())
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "UsingDeclaration");  
  		}
  		catch(ParseEOFException eof)
  		{
    
  		}  
	}
}

void VariableDeclaration(): { RecoverySet recoverySet = First.VariableDeclaration; }
{
  	try
  	{
  		(DataType() (IDList())+ SemiColon())
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "VariableDeclaration");  
  		}
  		catch(ParseEOFException eof)
  		{
    
  		}  
	}
}

void DataType(): { RecoverySet recoverySet = First.DataType;}
{
  	try
  	{
  		IntegerType() | StringType() | BoolType()
	}
	catch(ParseException e)
	{
	  	try
	  	{
	    	consumeUntil(recoverySet, e, "DataType");  
	  	}
	  	catch(ParseEOFException eof)
	  	{

	  	}  
	}
}
  
void IDList(): { RecoverySet recoverySet = First.IDList; }
{
	try
  	{
		Id() (VariableInit())? | Comma() Id() (VariableInit())?
	}
	catch(ParseException e)
	{
	  	try
	  	{
	    	consumeUntil(recoverySet, e, "IDList");  
	  	}
	  	catch(ParseEOFException eof)
	  	{

	  	}  
	}
}

void StartScript(): { }
{
  	<STARTSCRIPT>
}

void DoublePoints(): { }
{
  	<DOUBLEPOINTS>
}

void Id(): { }
{
  	<ID>
}

void LBrace(): { }
{
  	<LBRACE>
}

void RBrace(): { }
{
  	<RBRACE>
}

void SemiColon(): { }
{
  	<SEMICOLON>
}

void Assign(): { }
{
  	<ASSIGN>
}

void Number(): { }
{
  	<NUMBER>
}

void StringDelimit(): { }
{
  	<VARCHARDELIMITER>
}

void IF(): { }
{
  	< IF >
}

void Then(): { }
{
  	<THEN>
}

void Else(): { }
{
  	<ELSE>
}

void FOR(): { }
{
  	<FOR>
}

void To(): { }
{
  	<TO>
}

void WHILE(): { }
{
  	<WHILE>
}

void Sum(): { }
{
  	<SUM>
}

void Minus(): { }
{
  	<MINUS>
}

void Plus(): { }
{
  	<PLUS>
}

void Divide(): { }
{
  	<DIVIDE>
}

void Greater(): { }
{
  	<GREATER>
}

void Less(): { }
{
  	<LESS>
}

void GreaterEqual(): { }
{
  	<GREATEREQUAL>
}

void LessEqual(): { }
{
  	<LESSEQUAL>
}

void Difference(): { }
{
  	<DIFFERENCE>
}

void Equal(): { }
{
  	<EQUAL>
}

void Using(): { }
{
	<USING>
}

void IntegerType(): { }
{
	<INTEGERTYPE>
}

void StringType(): { }
{
	<STRINGTYPE>
}

void BoolType(): { }
{
	<BOOLTYPE>
}

void Comma(): { }
{
	<COMMA>
}


















	  		








