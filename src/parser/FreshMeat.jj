/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. FreshMeat.jj */
/*@egen*//**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  static = true;
}

PARSER_BEGIN(FreshMeat)

package parser;
import recovery.*;

public class FreshMeat/*@bgen(jjtree)*/implements FreshMeatTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTFreshMeatState jjtree = new JJTFreshMeatState();

/*@egen*/
  public static void main(String args []) throws ParseException
  {
    FreshMeat parser = new FreshMeat(System.in);
    while (true)
    {
      System.out.println("Lendo atrav\u00e9s da entrada padr\u00e3o...");
      System.out.print("Digite uma express\u00e3o:");

      SimpleNode simpleNode = FreshMeat.start();
      simpleNode.dump("");
      try
      {
        /*switch (FreshMeat.start())
        {
          case 0 : 
          System.out.println("OK.");
          break;
          case 1 : 
          System.out.println("Tchau.");
          break;
          default : 
          break;
        }*/
      }
      catch (Exception e)
      {
        System.out.println("Exception: A express\u00e3o inserida n\u00e3o est\u00e1 correta, verifique por favor com as instru\u00e7\u00f5es abaixo e tente novamente.");
        System.out.println(e.getMessage());
        FreshMeat.ReInit(System.in);
      }
      catch (Error e)
      {
        System.out.println("Error: A entrada inserida n\u00e3o \u00e9 um token v\u00e1lido, revise por favor e tente novamente");
        System.out.println(e.getMessage());
        break;
      }
    }
  }

  static public String im(int x)
  {
    int k;
	String s;
    s = tokenImage[x];
    k = s.lastIndexOf("\"");
    try {
      s = s.substring(1,k);
    }
   catch (StringIndexOutOfBoundsException e)
	   {}
   return s;
  }
	 
  static Token lastError = null;
  static boolean eof;    // vari\u00e1vel que indica se EOF foi alcan\u00e7ado
	
  // o m\u00e9todo abaixo consome tokens at\u00e9 alcan\u00e7ar um que perten\u00e7a ao conjunto
  // de sincroniza\u00e7\u00e3o
  static void consumeUntil(RecoverySet g,
	                 ParseException e,
	                 String met) throws ParseEOFException,
	                                    ParseException
  {
	Token tok;
	System.out.println();
	System.out.println("*** " + met + " ***");
	System.out.println("     Conjunto de sincroniza\u00e7\u00e3o: " + g);
		
	if (g == null) throw e; // se o conjunto \u00e9 null, propaga a exce\u00e7\u00e3o
	
	tok = getToken(1); // pega token corrente
	while ( ! eof )	{ // se n\u00e3o chegou ao fim do arquivo
	  if ( g.contains(tok.kind)) {//achou um token no conjunto
	    System.out.println("     Encontrado token de sincroniza\u00e7\u00e3o: " + 
	                       im(tok.kind));
	    break;
	  }
	  System.out.println("     Ignorando o token: " + im(tok.kind));
	  getNextToken();     // pega pr\u00f3ximo token       
      tok = getToken(1);
	  if (tok.kind == EOF && ! g.contains(EOF) ) // fim da entrada?   
	      eof = true;
	}
    if ( tok != lastError)  {
	  System.out.println(e.getMessage());
	  lastError = tok;
	   
	}
	if ( eof )
	  throw new ParseEOFException("Encontrei EOF onde n\u00e3o deveria.");
  }
  
}

PARSER_END(FreshMeat)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

TOKEN : /* Reserved words */
{
  	< STARTSCRIPT : "Start" >
| 	< INTEGERTYPE : "int" >
| 	< STRINGTYPE : "string" >
| 	< BOOLTYPE : "bool" >
| 	< USING : "using" >
| 	< IF : "if">
| 	< THEN : "then">
| 	< ELSE : "else">
| 	< FOR : "for">
| 	< TO : "to">
| 	< WHILE : "while" >
|   < NUMBER: (<DIGIT>)+ ( "." (<DIGIT>)+ )? >
| 	< #DIGIT : [ "0"-"9" ] >
| 	< OPENBLOCK : "{" >
| 	< CLOSEBLOCK : "}" >

}

TOKEN : /*OPERADORES*/
{
	< SUM: "+" >
|	< MINUS: "-" >
|	< PLUS: "*" >
|	< DIVIDE: "/" >	
|	< ASSIGNMENT: "=">
|	< GREATER: ">" >
|	< LESS: "<" >
|	< GREATEREQUAL: ">=" >
|	< LESSEQUAL: "<=" >
|	< DIFFERENCE: "!=" >
|	< EQUAL: "==" >
	
}

TOKEN :
{
 	< ID  : < LETTER > (< LETTER > | < DIGIT >)* >
| 	< LETTER : ["A"-"Z" ] | ["a"-"z"] >
| 	< VARCHARDELIMITER : "'" >
| 	< SEMICOLON : ";" >
| 	< COMMA : "," >
| 	< DOUBLEPOINTS : ":" >
| 	< LEFTPARENT : "(" >
| 	< RIGHTPARENT : ")" >
| 	< HASHTAG : "#" >

}

SimpleNode start() :{/*@bgen(jjtree) start */
  SimpleNode jjtn000 = new SimpleNode(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) start */
        try {
/*@egen*/
	(UsingDeclaration())*
	  
	<STARTSCRIPT> <DOUBLEPOINTS> <ID> 
	<OPENBLOCK>
	
		(Block())+
	
	<CLOSEBLOCK>/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
	
{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
 
void Block(): {/*@bgen(jjtree) Block */
  SimpleNode jjtn000 = new SimpleNode(JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Block */
        try {
/*@egen*/
  	(VariableDeclaration())*

  	Command()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Command(): {/*@bgen(jjtree) Command */
  SimpleNode jjtn000 = new SimpleNode(JJTCOMMAND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Command */
        try {
/*@egen*/
	Assignment()

	//Variable() < ASSIGNMENT > MathExpression() < SEMICOLON >

	// deixei assim pra visualizar os pulos pela procura de token do lookahead
| 	LOOKAHEAD(2)<IF> LogicExpression() <THEN>
				(<OPENBLOCK>	Command()	<CLOSEBLOCK> )
				(<ELSE>		<OPENBLOCK>		Command()	<CLOSEBLOCK> )? 
 
| 	ForTo()

| 	While()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
 	
}

void Assignment(): {/*@bgen(jjtree) Assignment */
  SimpleNode jjtn000 = new SimpleNode(JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Assignment */
        try {
/*@egen*/
	<ID> Inicialization() <SEMICOLON>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Inicialization(): {/*@bgen(jjtree) Inicialization */
  SimpleNode jjtn000 = new SimpleNode(JJTINICIALIZATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Inicialization */
        try {
/*@egen*/
  	<ASSIGNMENT> (<NUMBER> | <VARCHARDELIMITER> <ID> <VARCHARDELIMITER>)/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ForTo(): {/*@bgen(jjtree) ForTo */
  SimpleNode jjtn000 = new SimpleNode(JJTFORTO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) ForTo */
        try {
/*@egen*/
	<FOR> Assignment() <TO> ExpressionArguments()
 	(<OPENBLOCK>
 		Command()
 	<CLOSEBLOCK> )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void While(): {/*@bgen(jjtree) While */
  SimpleNode jjtn000 = new SimpleNode(JJTWHILE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) While */
        try {
/*@egen*/
	<WHILE> LogicExpression()
 	(<OPENBLOCK>
 		Command()
 	<CLOSEBLOCK> )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
} 

void LogicExpression(): {/*@bgen(jjtree) LogicExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTLOGICEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LogicExpression */
        try {
/*@egen*/
  	ExpressionArguments() (LogicOperator() ExpressionArguments())+/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void MathExpression() : {/*@bgen(jjtree) MathExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTMATHEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MathExpression */
        try {
/*@egen*/
	ExpressionArguments() (MathOperator() ExpressionArguments())+/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void ExpressionArguments(): {/*@bgen(jjtree) ExpressionArguments */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSIONARGUMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExpressionArguments */
        try {
/*@egen*/
  	< ID > | < NUMBER >/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void MathOperator(): {/*@bgen(jjtree) MathOperator */
  SimpleNode jjtn000 = new SimpleNode(JJTMATHOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) MathOperator */
                try {
/*@egen*/
		< SUM >
	|	< MINUS >
	|	< PLUS >
	|	< DIVIDE >/*@bgen(jjtree)*/
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/	
}

void LogicOperator(): {/*@bgen(jjtree) LogicOperator */
  SimpleNode jjtn000 = new SimpleNode(JJTLOGICOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) LogicOperator */
                try {
/*@egen*/
  		< GREATER >
	|	< LESS>
	|	< GREATEREQUAL>
	|	< LESSEQUAL>
	|	< DIFFERENCE>
	|	< EQUAL>/*@bgen(jjtree)*/
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}

void UsingDeclaration(): {/*@bgen(jjtree) UsingDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTUSINGDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) UsingDeclaration */
  try {
/*@egen*/
  (<USING> <ID> <SEMICOLON>)/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void VariableDeclaration(): {/*@bgen(jjtree) VariableDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTVARIABLEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VariableDeclaration */
  try {
/*@egen*/
  (DataType() (IDList())+ <SEMICOLON>)/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void DataType(): {/*@bgen(jjtree) DataType */
  SimpleNode jjtn000 = new SimpleNode(JJTDATATYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DataType */
  try {
/*@egen*/
  < INTEGERTYPE > | < STRINGTYPE > | < BOOLTYPE >/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void IDList(): {/*@bgen(jjtree) IDList */
  SimpleNode jjtn000 = new SimpleNode(JJTIDLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) IDList */
         try {
/*@egen*/
	 <ID> (Inicialization())? | <COMMA> <ID> (Inicialization())?/*@bgen(jjtree)*/
         } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             throw (RuntimeException)jjte000;
           }
           if (jjte000 instanceof ParseException) {
             throw (ParseException)jjte000;
           }
           throw (Error)jjte000;
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
           }
         }
/*@egen*/ 
}
 
//void Semicolon(): { }
//{
//  	<SEMICOLON>
//}


