/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. FreshMeat.jj */
/*@egen*//**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  static = true;
  DEBUG_PARSER = true;
}

PARSER_BEGIN(FreshMeat)

package parser;
import recovery.*;
import java.io.*;

public class FreshMeat/*@bgen(jjtree)*/implements FreshMeatTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTFreshMeatState jjtree = new JJTFreshMeatState();

/*@egen*/
	private static String myFile = "";
	int contParseError = 0;	// contador de erros sint\u00e1ticos
	
	// funo para abertura de arquivo a ser usado como source para leitura de tokens
	public static java.io.BufferedReader abreArquivo (String file)
	{
		java.io.BufferedReader in;
		java.io.File arquivinho = new java.io.File(file);
    	try
    	{
         	in= new java.io.BufferedReader(new java.io.FileReader(arquivinho));
    	}
    	catch(java.io.IOException e)
    	{
    		in = null;
    		System.out.println("Arquivo n\u00e3o pode ser aberto.");
    	}		
		return (in);	
	}
	
	public static void main(String args []) throws ParseException
  	{
    	FreshMeat parser;     // analisador l\u00e9xico/sint\u00e1tico

		// Receba o arquivo aberto, leia uma linha 
	 	try
	 	{
			//Verifica se ja nao ha arquivo escolhido
	 		if (myFile.equals(""))
	 		{
	 			//Cria o Seletor de arquivos e seta o disco "C:" como default
		 		javax.swing.JFileChooser arquivo = new javax.swing.JFileChooser();
		 		
		 		//Habilita para escolha  
	            arquivo.showOpenDialog(null);
	            
				//Recebe o Path do arquivo
	            myFile = arquivo.getSelectedFile().getAbsolutePath();
		 	    
				//Abre o arquivo no endereco escolhido
	         	java.io.BufferedReader aux = abreArquivo(myFile);
	            String str;  
	            java.io.StringReader sr = new java.io.StringReader( aux.readLine());
		        java.io.Reader r = new java.io.BufferedReader( sr );		
	   	        parser = new FreshMeat( abreArquivo(myFile));
		        java.io.BufferedReader in = aux;
    	
	            // enquanto houverem linhas, as leio;
	            while ((str = in.readLine()) != null)
	            {
	            	sr = new java.io.StringReader( str);
		        	r = new java.io.BufferedReader( sr );
	            }
            	//Encerra o buffer  
            	in.close();
	 		}
    	}
    	catch (java.io.IOException e)
    	{
			javax.swing.JOptionPane.showMessageDialog(null,"Erro ao iniciar o Analisador Lexico!");
        }

      	try
      	{
      		SimpleNode simpleNode = FreshMeat.start();
      		simpleNode.dump(""); 				
      	}
      	catch (ParseException e)
      	{
       		System.out.println("Exception: A express\u00e3o inserida n\u00e3o est\u00e1 correta, verifique por favor com as instru\u00e7\u00f5es abaixo e tente novamente.");
        	System.out.println(e.getMessage());
        	System.out.println(e);
		  	//parser.contParseError = 1;   // n\u00e3o existe recupera\u00e7\u00e3o de erros
			//System.exit(0);			  	
      	}
      	catch (Error e)
      	{
       		System.out.println("Error: A entrada inserida n\u00e3o \u00e9 um token v\u00e1lido, revise por favor e tente novamente");
        	System.out.println(e.getMessage());
      	}
//     	finally
//    	{
//      	System.out.println(token_source.foundLexError() + " Lexical Errors found");
//        	System.out.println(contParseError + " Syntactic Errors found");
//     	}  
  	}
		
	static public String im(int x)
	{
    	int k;
		String s;
	    s = tokenImage[x];
	    k = s.lastIndexOf("\"");
    	try
    	{
	      s = s.substring(1,k);
    	}
	   	catch (StringIndexOutOfBoundsException e)
	   	{
   	  	}
	   	return s;
	  }
		 
	  static Token lastError = null;
	  static boolean eof;    // vari\u00e1vel que indica se EOF foi alcan\u00e7ado
		
	  // o m\u00e9todo abaixo consome tokens at\u00e9 alcan\u00e7ar um que perten\u00e7a ao conjunto
	  // de sincroniza\u00e7\u00e3o
	  static void consumeUntil(RecoverySet g,
		                 ParseException e,
		                 String met) throws ParseEOFException,
		                                    ParseException
	  {
		Token tok;
		System.out.println();
		System.out.println("*** " + met + " ***");
		System.out.println("     Conjunto de sincroniza\u00e7\u00e3o: " + g);
			
		if (g == null) throw e; // se o conjunto \u00e9 null, propaga a exce\u00e7\u00e3o
		
		tok = getToken(1); // pega token corrente
		while ( ! eof )	{ // se n\u00e3o chegou ao fim do arquivo
		  if ( g.contains(tok.kind)) {//achou um token no conjunto
		    System.out.println("     Encontrado token de sincroniza\u00e7\u00e3o: " + 
		                       im(tok.kind));
		    break;
		  }
		  System.out.println("     Ignorando o token: " + im(tok.kind));
		  getNextToken();     // pega pr\u00f3ximo token       
	      tok = getToken(1);
		  if (tok.kind == EOF && ! g.contains(EOF) ) // fim da entrada?   
		      eof = true;
		}
	    if ( tok != lastError)  {
		  System.out.println(e.getMessage());
		  lastError = tok;
		   
		}
		if ( eof )
		  throw new ParseEOFException("Encontrei EOF onde n\u00e3o deveria.");
	  }
  
}

PARSER_END(FreshMeat)

TOKEN_MGR_DECLS :
{
	int countLexError = 0;
	
	public int foundLexError()
	{
	   return countLexError;
	}
}

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

TOKEN : /* Reserved words */
{
  	< STARTSCRIPT : "Start" >
| 	< INTEGERTYPE : "int" >
| 	< STRINGTYPE : "string" >
| 	< BOOLTYPE : "bool" >
| 	< USING : "using" >
| 	< IF : "if">
| 	< THEN : "then">
| 	< ELSE : "else">
| 	< FOR : "for">
| 	< TO : "to">
| 	< WHILE : "while" >

}

TOKEN : /* Operadores */
{
	< SUM: "+" >
|	< MINUS: "-" >
|	< PLUS: "*" >
|	< DIVIDE: "/" >	
|	< ASSIGN: "="> 
|	< GREATER: ">" >
|	< LESS: "<" >
|	< GREATEREQUAL: ">=" >
|	< LESSEQUAL: "<=" >
|	< DIFFERENCE: "!=" >
|	< EQUAL: "==" >	

}

TOKEN: /* Simbolos especiais */
{
	< LBRACE : "{" >
| 	< RBRACE : "}" >
| 	< VARCHARDELIMITER : "'" >
| 	< SEMICOLON : ";" >
| 	< COMMA : "," >
| 	< DOUBLEPOINTS : ":" >
| 	< LPARENT : "(" >
| 	< RPARENT : ")" >
| 	< HASHTAG : "#" >

}

TOKEN :
{
 	< ID  : < LETTER > (< LETTER > | < DIGIT >)* >
| 	< LETTER : ["A"-"Z" ] | ["a"-"z"] >
|   < NUMBER: (<DIGIT>)+ ( "." (<DIGIT>)+ )? >
| 	< #DIGIT : [ "0"-"9" ] >

}

SKIP:
{
	"/*": multilinecomment
}

< multilinecomment > SKIP:
{
  	"*/": DEFAULT
| 	< ~ [] >
}

SKIP:
{
	"//": singlelinecomment
}

< singlelinecomment > SKIP:
{ 
  	< ["\n", "\r"] >: DEFAULT
| 	< ~ [] >
}

SimpleNode start() :{/*@bgen(jjtree) start */
                      SimpleNode jjtn000 = new SimpleNode(JJTSTART);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/ RecoverySet recoverySet = First.start; }
{/*@bgen(jjtree) start */
        try {
/*@egen*/
	try
  	{
		(UsingDeclaration())*
		  
		<STARTSCRIPT> <DOUBLEPOINTS> <ID> 
		<LBRACE>
		
			(Block())+
		
		<RBRACE>
		
		{ return jjtn000; }
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "start");  
  		}
  		catch(ParseEOFException eof)
  		{
    
  		}  
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/

}
   
void Block(): {/*@bgen(jjtree) Block */
                SimpleNode jjtn000 = new SimpleNode(JJTBLOCK);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/ RecoverySet recoverySet = First.Block; }
{/*@bgen(jjtree) Block */
        try {
/*@egen*/
  	try
  	{
  		(VariableDeclaration())*
  	
  		Command() 
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "Block");  
  		}
  		catch(ParseEOFException eof)
  		{
    
  		}  
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Command(): {/*@bgen(jjtree) Command */
                  SimpleNode jjtn000 = new SimpleNode(JJTCOMMAND);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/ RecoverySet recoverySet = First.Command; }
{/*@bgen(jjtree) Command */
        try {
/*@egen*/
	try
  	{
			VariableAssignment()
		
			//Variable() < ASSIGN > MathExpression() < SEMICOLON >
		
		| 	If()
		 
		| 	ForTo()
		
		| 	While()
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "Command");  
  		}
  		catch(ParseEOFException eof)
  		{
     
  		}  
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void VariableAssignment(): {/*@bgen(jjtree) VariableAssignment */
  SimpleNode jjtn000 = new SimpleNode(JJTVARIABLEASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VariableAssignment */
        try {
/*@egen*/
	<ID> VariableInit() <SEMICOLON>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void VariableInit(): {/*@bgen(jjtree) VariableInit */
  SimpleNode jjtn000 = new SimpleNode(JJTVARIABLEINIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) VariableInit */
        try {
/*@egen*/
  	<ASSIGN> Y()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Y(): {/*@bgen(jjtree) Y */
  SimpleNode jjtn000 = new SimpleNode(JJTY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Y */
        try {
/*@egen*/
  	( (<NUMBER> | <ID>) (DoMath())* ) | W()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void W(): {/*@bgen(jjtree) W */
  SimpleNode jjtn000 = new SimpleNode(JJTW);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) W */
         try {
/*@egen*/
  	 (<VARCHARDELIMITER> <ID> <VARCHARDELIMITER>)/*@bgen(jjtree)*/
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
           }
         }
/*@egen*/ 
}

void DoMath(): {/*@bgen(jjtree) DoMath */
  SimpleNode jjtn000 = new SimpleNode(JJTDOMATH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) DoMath */
         try {
/*@egen*/
	 (MathOperator() ExpressionArguments())/*@bgen(jjtree)*/
         } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             throw (RuntimeException)jjte000;
           }
           if (jjte000 instanceof ParseException) {
             throw (ParseException)jjte000;
           }
           throw (Error)jjte000;
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
           }
         }
/*@egen*/
}

void If(): {/*@bgen(jjtree) If */
             SimpleNode jjtn000 = new SimpleNode(JJTIF);
             boolean jjtc000 = true;
             jjtree.openNodeScope(jjtn000);
/*@egen*/ RecoverySet recoverySet = First.If; }
{/*@bgen(jjtree) If */
        try {
/*@egen*/
	try
  	{
		<IF> LogicExpression() <THEN>
				(<LBRACE>	Command()	<RBRACE> )
				(<ELSE>		<LBRACE>		Command()	<RBRACE> )?
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "If");  
  		}
  		catch(ParseEOFException eof)
  		{
    
  		}  
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/			
}

void ForTo(): {/*@bgen(jjtree) ForTo */
                SimpleNode jjtn000 = new SimpleNode(JJTFORTO);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/ RecoverySet recoverySet = First.ForTo; }
{/*@bgen(jjtree) ForTo */
        try {
/*@egen*/
	try
  	{
		<FOR> VariableAssignment() <TO> ExpressionArguments()
	 	(<LBRACE>
	 		Command()
	 	<RBRACE> )
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "ForTo");  
  		}
  		catch(ParseEOFException eof)
  		{
    
  		}  
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void While(): {/*@bgen(jjtree) While */
                SimpleNode jjtn000 = new SimpleNode(JJTWHILE);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/ RecoverySet recoverySet = First.While; }
{/*@bgen(jjtree) While */
        try {
/*@egen*/ 
	try
  	{
		<WHILE> LogicExpression()
	 	(<LBRACE>
	 		Command()
	 	<RBRACE> )
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "While");  
  		}
  		catch(ParseEOFException eof)
  		{
    
  		}  
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/	
} 

void LogicExpression(): {/*@bgen(jjtree) LogicExpression */
                          SimpleNode jjtn000 = new SimpleNode(JJTLOGICEXPRESSION);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/ RecoverySet recoverySet = First.LogicExpression; }
{/*@bgen(jjtree) LogicExpression */
        try {
/*@egen*/
	try
  	{
  		ExpressionArguments() (LogicOperator() ExpressionArguments())+
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "LogicExpression");  
  		}
  		catch(ParseEOFException eof)
  		{
    
  		}  
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//void MathExpression() : { /*RecoverySet recoverySet = First.MathExpression; */}
//{
//	/*try
//  	{*/
//		ExpressionArguments() (MathOperator() ExpressionArguments())+
//	//}
//	/*
//	catch(ParseException e)
//	{
//  		try
//  		{		
//			consumeUntil(recoverySet, e, "MathExpression");  
//  		}
//  		catch(ParseEOFException eof)
//  		{
//    
//  		}  
//	}
//	*/
//	
//}

void ExpressionArguments(): {/*@bgen(jjtree) ExpressionArguments */
                              SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSIONARGUMENTS);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);
/*@egen*/ RecoverySet recoverySet = First.ExpressionArguments; }
{/*@bgen(jjtree) ExpressionArguments */
        try {
/*@egen*/
	try
  	{
  		< ID > | < NUMBER >
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "ExpressionArguments");  
  		}
  		catch(ParseEOFException eof)
  		{
    
  		}  
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void MathOperator(): {/*@bgen(jjtree) MathOperator */
                       SimpleNode jjtn000 = new SimpleNode(JJTMATHOPERATOR);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
/*@egen*/ RecoverySet recoverySet = First.MathOperator; }
{/*@bgen(jjtree) MathOperator */
        try {
/*@egen*/
	try
  	{
			< SUM >
		|	< MINUS >
		|	< PLUS >
		|	< DIVIDE >
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "MathOperator");  
  		}
  		catch(ParseEOFException eof)
  		{
    
  		}  
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void LogicOperator(): {/*@bgen(jjtree) LogicOperator */
                        SimpleNode jjtn000 = new SimpleNode(JJTLOGICOPERATOR);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
/*@egen*/ RecoverySet recoverySet = First.LogicOperator; }
{/*@bgen(jjtree) LogicOperator */
        try {
/*@egen*/
	try
  	{
	  		< GREATER >
		|	< LESS>
		|	< GREATEREQUAL>
		|	< LESSEQUAL>
		|	< DIFFERENCE>
		|	< EQUAL>
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "LogicOperator");  
  		}
  		catch(ParseEOFException eof)
  		{
    
  		}  
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void UsingDeclaration(): {/*@bgen(jjtree) UsingDeclaration */
                           SimpleNode jjtn000 = new SimpleNode(JJTUSINGDECLARATION);
                           boolean jjtc000 = true;
                           jjtree.openNodeScope(jjtn000);
/*@egen*/ RecoverySet recoverySet = First.UsingDeclaration; }
{/*@bgen(jjtree) UsingDeclaration */
        try {
/*@egen*/
	try
  	{
  		(<USING> <ID> <SEMICOLON>)
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "UsingDeclaration");  
  		}
  		catch(ParseEOFException eof)
  		{
    
  		}  
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void VariableDeclaration(): {/*@bgen(jjtree) VariableDeclaration */
                              SimpleNode jjtn000 = new SimpleNode(JJTVARIABLEDECLARATION);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);
/*@egen*/ RecoverySet recoverySet = First.VariableDeclaration; }
{/*@bgen(jjtree) VariableDeclaration */
        try {
/*@egen*/
  	try
  	{
  		(DataType() (IDList())+ <SEMICOLON>)
	}
	catch(ParseException e)
	{
  		try
  		{		
			consumeUntil(recoverySet, e, "VariableDeclaration");  
  		}
  		catch(ParseEOFException eof)
  		{
    
  		}  
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void DataType(): {/*@bgen(jjtree) DataType */
                   SimpleNode jjtn000 = new SimpleNode(JJTDATATYPE);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/ RecoverySet recoverySet = First.DataType;}
{/*@bgen(jjtree) DataType */
        try {
/*@egen*/
  	try
  	{
  		< INTEGERTYPE > | < STRINGTYPE > | < BOOLTYPE >
	}
	catch(ParseException e)
	{
	  	try
	  	{
	    	consumeUntil(recoverySet, e, "DataType");  
	  	}
	  	catch(ParseEOFException eof)
	  	{

	  	}  
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
  
void IDList(): {/*@bgen(jjtree) IDList */
                 SimpleNode jjtn000 = new SimpleNode(JJTIDLIST);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);
/*@egen*/ RecoverySet recoverySet = First.IDList; }
{/*@bgen(jjtree) IDList */
        try {
/*@egen*/
	try
  	{
		<ID> (VariableInit())? | <COMMA> <ID> (VariableInit())?
	}
	catch(ParseException e)
	{
	  	try
	  	{
	    	consumeUntil(recoverySet, e, "IDList");  
	  	}
	  	catch(ParseEOFException eof)
	  	{

	  	}  
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
 
//void Semicolon(): { }
//{
//  	<SEMICOLON>
//}


